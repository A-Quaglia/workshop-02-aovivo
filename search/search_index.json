{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Workshop 02 - Data Quality","text":"<p>Para desenvolver o desafio de negocio, vamos montar a seguinte ETL</p>"},{"location":"#fluxo","title":"Fluxo","text":"<pre><code>graph TD;\n    A[Configura Vari\u00e1veis] --&gt; B[Ler o Banco SQL];\n    B --&gt; V[Valida\u00e7\u00e3o do Schema de Entrada];\n    V --&gt;|Falha| X[Alerta de Erro];\n    V --&gt;|Sucesso| C[Transformar os KPIs];\n    C --&gt; Y[Valida\u00e7\u00e3o do Schema de Sa\u00edda];\n    Y --&gt;|Falha| Z[Alerta de Erro];\n    Y --&gt;|Sucesso| D[Salvar no DuckDB];\n</code></pre>"},{"location":"#contrato-de-dados","title":"Contrato de dados","text":"<p>             Bases: <code>SchemaModel</code></p> <p>Esquema para representar dados de produtos.</p> <p>Attributes:</p> Name Type Description <code>id_produto</code> <code>Series[int]</code> <p>S\u00e9rie contendo IDs de produtos.</p> <code>nome</code> <code>Series[str]</code> <p>S\u00e9rie contendo nomes de produtos.</p> <code>quantidade</code> <code>Series[int]</code> <p>S\u00e9rie contendo quantidades de produtos (deve ser maior ou igual a 0).</p> <code>preco</code> <code>Series[float]</code> <p>S\u00e9rie contendo pre\u00e7os de produtos (deve ser maior ou igual a 0).</p> <code>categoria</code> <code>Series[str]</code> <p>S\u00e9rie contendo categorias de produtos.</p> <code>email</code> <code>Series[str]</code> <p>E-mail associado ao produto, deve seguir o formato padr\u00e3o de e-mails.</p> Source code in <code>app\\schema.py</code> <pre><code>class ProdutoSchema(pa.SchemaModel):\n    \"\"\"\n    Esquema para representar dados de produtos.\n\n    Attributes:\n        id_produto (pandas.Series[int]): S\u00e9rie contendo IDs de produtos.\n        nome (pandas.Series[str]): S\u00e9rie contendo nomes de produtos.\n        quantidade (pandas.Series[int]): S\u00e9rie contendo quantidades de produtos (deve ser maior ou igual a 0).\n        preco (pandas.Series[float]): S\u00e9rie contendo pre\u00e7os de produtos (deve ser maior ou igual a 0).\n        categoria (pandas.Series[str]): S\u00e9rie contendo categorias de produtos.\n        email (Series[str]): E-mail associado ao produto, deve seguir o formato padr\u00e3o de e-mails.\n    \"\"\"\n    id_produto: Series[int]\n    nome: Series[str]\n    quantidade: Series[int] = pa.Field(ge=0)\n    preco: Series[float] = pa.Field(ge=0)\n    categoria: Series[str]\n    email: Series[str] = pa.Field(regex=email_regex)\n\n    class Config:\n        coerce = True\n</code></pre>"},{"location":"#transformacoes","title":"Transforma\u00e7\u00f5es","text":""},{"location":"#configura-variaveis","title":"Configura Vari\u00e1veis","text":"<p>Carrega as configura\u00e7\u00f5es a partir de vari\u00e1veis de ambiente.</p> Source code in <code>app\\etl.py</code> <pre><code>def load_settings():\n    \"\"\"Carrega as configura\u00e7\u00f5es a partir de vari\u00e1veis de ambiente.\"\"\"\n    dotenv_path = Path.cwd() / '.env'\n    load_dotenv(dotenv_path=dotenv_path)\n\n    settings = {\n        \"db_host\": os.getenv(\"POSTGRES_HOST\"),\n        \"db_user\": os.getenv(\"POSTGRES_USER\"),\n        \"db_pass\": os.getenv(\"POSTGRES_PASSWORD\"),\n        \"db_name\": os.getenv(\"POSTGRES_DB\"),\n        \"db_port\": os.getenv(\"POSTGRES_PORT\"),\n    }\n    return settings\n</code></pre>"},{"location":"#ler-o-banco-sql","title":"Ler o Banco SQL","text":"Source code in <code>app\\etl.py</code> <pre><code>@pa.check_output(ProdutoSchema)\ndef extrair_do_sql(query: str) -&gt; pd.DataFrame:\n    settings = load_settings()\n\n    # Criar a string de conex\u00e3o com base nas configura\u00e7\u00f5es\n    connection_string = f\"postgresql://{settings['db_user']}:{settings['db_pass']}@{settings['db_host']}:{settings['db_port']}/{settings['db_name']}\"\n\n    # Criar engine de conex\u00e3o\n    engine = create_engine(connection_string)\n\n    with engine.connect() as conn, conn.begin():\n            df_crm = pd.read_sql(query, conn)\n\n    return df_crm\n</code></pre>"},{"location":"#transformar-os-kpis","title":"Transformar os KPIs","text":"<p>Transforma os dados do DataFrame aplicando c\u00e1lculos e normaliza\u00e7\u00f5es.</p> <p>Attributes:</p> Name Type Description <code>df</code> <p>DataFrame do Pandas contendo os dados originais.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame do Pandas ap\u00f3s a aplica\u00e7\u00e3o das transforma\u00e7\u00f5es.</p> Source code in <code>app\\etl.py</code> <pre><code>@pa.check_input(ProdutoSchema)\n@pa.check_output(ProdutoSchemaKPI)\ndef transformar(df: pd.DataFrame) -&gt; pd.DataFrame:\n    \"\"\"\n    Transforma os dados do DataFrame aplicando c\u00e1lculos e normaliza\u00e7\u00f5es.\n\n    Attributes:\n        df: DataFrame do Pandas contendo os dados originais.\n\n    Returns:\n        DataFrame do Pandas ap\u00f3s a aplica\u00e7\u00e3o das transforma\u00e7\u00f5es.\n    \"\"\"\n    # Calcular valor_total_estoque\n    df['valor_total_estoque'] = df['quantidade'] * df['preco']\n\n    # Normalizar categoria para mai\u00fasculas\n    df['categoria_normalizada'] = df['categoria'].str.lower()\n\n    # Determinar disponibilidade (True se quantidade &gt; 0)\n    df['disponibilidade'] = df['quantidade'] &gt; 0\n\n    return df\n</code></pre>"},{"location":"#salvar-no-duckdb","title":"Salvar no DuckDB","text":"<p>Carrega o DataFrame no DuckDB, criando ou substituindo a tabela especificada.</p> <p>Attributes:</p> Name Type Description <code>df</code> <p>DataFrame do Pandas para ser carregado no DuckDB.</p> <code>table_name</code> <p>Nome da tabela no DuckDB onde os dados ser\u00e3o inseridos.</p> <code>db_file</code> <p>Caminho para o arquivo DuckDB. Se n\u00e3o existir, ser\u00e1 criado.</p> Source code in <code>app\\etl.py</code> <pre><code>@pa.check_input(ProdutoSchemaKPI)\ndef load_to_duckdb(df: pd.DataFrame, table_name: str, db_file: str = 'my_duckdb.db'):\n    \"\"\"\n    Carrega o DataFrame no DuckDB, criando ou substituindo a tabela especificada.\n\n    Attributes:\n        df: DataFrame do Pandas para ser carregado no DuckDB.\n        table_name: Nome da tabela no DuckDB onde os dados ser\u00e3o inseridos.\n        db_file: Caminho para o arquivo DuckDB. Se n\u00e3o existir, ser\u00e1 criado.\n    \"\"\"\n    # Conectar ao DuckDB. Se o arquivo n\u00e3o existir, ele ser\u00e1 criado.\n    con = duckdb.connect(database=db_file, read_only=False)\n\n    # Registrar o DataFrame como uma tabela tempor\u00e1ria\n    con.register('df_temp', df)\n\n    # Utilizar SQL para inserir os dados da tabela tempor\u00e1ria em uma tabela permanente\n    # Se a tabela j\u00e1 existir, substitui.\n    con.execute(f\"CREATE OR REPLACE TABLE {table_name} AS SELECT * FROM df_temp\")\n\n    # Fechar a conex\u00e3o\n    con.close()\n</code></pre>"}]}